@require(name, inherit, ctors, public_vars, public_methods, nested_classes)
@import "function.template" as function

@def write_class(cls):
cdef class Py{@cls.name}(@for icls in cls.bases:
                @icls.name,
                @end):

    cdef {@cls.name} *this

    cdef __cinit__(self, *args, **kwargs):
        @for ctor in cls.ctors:
        if @ctor.param_types_tuple == @((type(arg) for arg in args)):
            self.this = new @{cls.name}(*args)
        @end
        return

    def __init__(self, *args, **kwargs):
        @for icls in cls.bases:
        @{icls.name}.__init__(self, *args, **kwargs)
        @end
        
        return

    def __dealloc__(self):
        if self.this != NULL:
            del self.this
        return

    @for pvar in [x for x in cls.variables if x.access_specifier == "public"]:
    @property
    def @{pvar.name}():
        return self._ptr.@pvar.name

    @{@pvar}.setter
    def @{pvar.name}(@pvar.type x):
        self._ptr.@{pvar.name} = x
        return

    @end

    @for pmeth in [x for x in cls.functions if x.access_specifier == "public"]:
    def @{pmeth.name}(
                    self,
                    @function.write_cython_parms(pmeth.parameters)
                    ):
        return self._ptr.@{pmeth.name}(@function.fill_args(pmeth.parameters))
    @end
@end
